@page "/rules"
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize(Policy = "RequireManager")]
@inject PayGuardAI.Data.ApplicationDbContext DbContext
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject PayGuardAI.Web.Services.CurrentUserService CurrentUser
@inject PayGuardAI.Core.Services.IRuleVersioningService VersioningService
@inject PayGuardAI.Core.Services.IRuleSuggestionService SuggestionService
@inject PayGuardAI.Core.Services.ITenantContext TenantContext
@using Microsoft.EntityFrameworkCore

<PageTitle>Risk Rules - PayGuard AI</PageTitle>

<MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-4" Style="flex-wrap: wrap; gap: 12px;">
    <MudText Typo="Typo.h4">
        <MudIcon Icon="@Icons.Material.Filled.Rule" Class="mr-2" />
        Risk Rule Configuration
    </MudText>
    <MudButton Variant="Variant.Filled" Color="Color.Primary" 
               StartIcon="@Icons.Material.Filled.Add"
               OnClick="@OpenAddRuleDialog">
        Add Custom Rule
    </MudButton>
    <MudButton Variant="Variant.Filled" Color="Color.Warning" 
               StartIcon="@Icons.Material.Filled.AccountTree"
               OnClick="@OpenAddCompoundRuleDialog">
        Add Compound Rule
    </MudButton>
</MudStack>

<MudAlert Severity="Severity.Info" Class="mb-4">
    <MudText>
        Configure risk scoring thresholds and weights. <strong>System rules</strong> (built-in) have hardcoded
        evaluation logic ‚Äî adjust their thresholds and weights. <strong>Custom rules</strong> evaluate dynamically
        based on the condition you define. <strong>Compound rules</strong> combine multiple conditions with AND/OR logic.
        Use <strong>Shadow mode</strong> to test a rule without affecting real scores. Changes apply to new transactions immediately.
    </MudText>
</MudAlert>

@if (_loading)
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
}
else
{
    @* ‚îÄ‚îÄ AI-Powered Rule Suggestions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ *@
    @if (_suggestions.Count > 0)
    {
        <MudPaper Class="pa-4 mb-5" Elevation="2" Style="border-left: 4px solid var(--mud-palette-info);">
            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-3">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Typo="Typo.h6">
                        üí° Smart Rule Suggestions
                    </MudText>
                    <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Filled">
                        @_suggestions.Count new
                    </MudChip>
                </MudStack>
                <MudStack Row="true" Spacing="1">
                    <MudTooltip Text="Refresh suggestions based on latest data">
                        <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small"
                                       OnClick="@LoadSuggestions" Disabled="@_loadingSuggestions" />
                    </MudTooltip>
                    <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Default"
                               OnClick="@(() => _suggestionsCollapsed = !_suggestionsCollapsed)">
                        @(_suggestionsCollapsed ? "Show" : "Hide")
                    </MudButton>
                </MudStack>
            </MudStack>

            @if (_loadingSuggestions)
            {
                <MudProgressLinear Color="Color.Info" Indeterminate="true" Class="mb-2" />
            }

            @if (!_suggestionsCollapsed)
            {
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
                    Based on analysis of flagged transactions from the last 30 days. Click <strong>"Create Rule"</strong> to adopt a suggestion.
                </MudText>

                <MudGrid>
                    @foreach (var suggestion in _suggestions)
                    {
                        <MudItem xs="12" md="6" lg="4">
                            <MudCard Elevation="1" Style="border-top: 3px solid var(--mud-palette-info); height: 100%;">
                                <MudCardContent>
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-2">
                                        <MudText Typo="Typo.subtitle1" Style="font-weight: 600;">
                                            @GetPatternIcon(suggestion.Pattern) @suggestion.Name
                                        </MudText>
                                        <MudTooltip Text="@($"Confidence: {suggestion.Confidence}%")">
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Filled"
                                                     Color="@GetConfidenceColor(suggestion.Confidence)">
                                                @suggestion.Confidence%
                                            </MudChip>
                                        </MudTooltip>
                                    </MudStack>

                                    <MudText Typo="Typo.body2" Class="mb-2">@suggestion.Description</MudText>

                                    <MudPaper Class="pa-2 mb-2" Elevation="0" Style="background-color: var(--mud-palette-background-grey);">
                                        <MudText Typo="Typo.body2">
                                            <MudIcon Icon="@Icons.Material.Filled.FilterAlt" Size="Size.Small" Class="mr-1" />
                                            When <strong>@GetFieldDisplayName(suggestion.ExpressionField)</strong>
                                            @GetOperatorDisplay(suggestion.ExpressionOperator)
                                            <strong>@suggestion.ExpressionValue</strong>
                                            ‚Üí +@suggestion.SuggestedWeight pts
                                        </MudText>
                                    </MudPaper>

                                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                                        <MudIcon Icon="@Icons.Material.Filled.Analytics" Size="Size.Small" Class="mr-1" />
                                        @suggestion.Evidence
                                    </MudText>
                                </MudCardContent>
                                <MudCardActions>
                                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small"
                                               StartIcon="@Icons.Material.Filled.Add"
                                               OnClick="@(() => CreateRuleFromSuggestion(suggestion))">
                                        Create Rule
                                    </MudButton>
                                    <MudSpacer />
                                    <MudTooltip Text="Dismiss this suggestion">
                                        <MudIconButton Icon="@Icons.Material.Filled.Close" Size="Size.Small"
                                                       Color="Color.Default"
                                                       OnClick="@(() => DismissSuggestion(suggestion))" />
                                    </MudTooltip>
                                </MudCardActions>
                            </MudCard>
                        </MudItem>
                    }
                </MudGrid>
            }
        </MudPaper>
    }
    else if (!_loadingSuggestions && _suggestionsLoaded)
    {
        <MudAlert Severity="Severity.Success" Dense="true" Class="mb-4">
            <MudText Typo="Typo.body2">
                ‚úÖ No new rule suggestions ‚Äî your current rules cover the observed patterns well.
                <MudLink OnClick="@LoadSuggestions" Typo="Typo.body2">Re-analyze</MudLink>
            </MudText>
        </MudAlert>
    }

    @* ‚îÄ‚îÄ System Rules (built-in) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ *@
    <MudText Typo="Typo.h6" Class="mb-2">
        <MudIcon Icon="@Icons.Material.Filled.Shield" Size="Size.Small" Class="mr-1" />
        System Rules
    </MudText>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
        Built-in fraud detection rules. Adjust thresholds and weights to tune sensitivity.
    </MudText>

    <MudGrid>
        @foreach (var rule in _rules.Where(r => r.IsBuiltIn))
        {
            <MudItem xs="12" md="6">
                <MudCard Elevation="2">
                    <MudCardHeader>
                        <CardHeaderContent>
                            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                <MudStack>
                                    <MudText Typo="Typo.h6">@rule.Name</MudText>
                                    <MudStack Row="true" Spacing="1">
                                        <MudChip T="string" Size="Size.Small" Color="@GetCategoryColor(rule.Category)">
                                            @rule.Category
                                        </MudChip>
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Default">
                                            System
                                        </MudChip>
                                    </MudStack>
                                </MudStack>
                                <MudSelect T="string" Value="@rule.Mode" Label="Mode"
                                           ValueChanged="@((val) => ChangeRuleMode(rule, val))"
                                           Variant="Variant.Outlined" Style="max-width: 140px;"
                                           Margin="Margin.Dense">
                                    <MudSelectItem T="string" Value="@("Active")">‚úÖ Active</MudSelectItem>
                                    <MudSelectItem T="string" Value="@("Shadow")">üëÅ Shadow</MudSelectItem>
                                    <MudSelectItem T="string" Value="@("Disabled")">‚õî Disabled</MudSelectItem>
                                </MudSelect>
                            </MudStack>
                        </CardHeaderContent>
                    </MudCardHeader>
                    <MudCardContent>
                        <MudText Typo="Typo.body2" Class="mb-3">@rule.Description</MudText>
                        
                        <MudGrid>
                            <MudItem xs="6">
                                @if (IsThresholdUsed(rule.RuleCode))
                                {
                                    <MudNumericField T="decimal" Label="@GetThresholdLabel(rule.RuleCode)" 
                                                     Value="@rule.Threshold"
                                                     ValueChanged="@((val) => UpdateThreshold(rule, val))"
                                                     Variant="Variant.Outlined" 
                                                     Min="0"
                                                     Disabled="@(rule.Mode != "Active")" />
                                }
                                else
                                {
                                    <MudTextField T="string" Label="Threshold" 
                                                  Value="@("N/A")" ReadOnly="true"
                                                  Variant="Variant.Outlined" Disabled="true"
                                                  HelperText="@GetThresholdHint(rule.RuleCode)" />
                                }
                            </MudItem>
                            <MudItem xs="6">
                                <MudNumericField T="int" Label="Score Weight" 
                                                 Value="@rule.ScoreWeight"
                                                 ValueChanged="@((val) => UpdateWeight(rule, val))"
                                                 Variant="Variant.Outlined"
                                                 Min="0" Max="50"
                                                 Disabled="@(rule.Mode != "Active")" />
                            </MudItem>
                        </MudGrid>
                        
                        @if (IsThresholdUsed(rule.RuleCode))
                        {
                            <MudText Typo="Typo.caption" Class="mt-2" Color="Color.Secondary">
                                @GetThresholdExplanation(rule)
                            </MudText>
                        }
                        
                        <MudText Typo="Typo.caption" Class="mt-1">
                            Last updated: @rule.UpdatedAt.ToString("MM/dd HH:mm") by <strong>@(rule.UpdatedBy ?? "system")</strong>
                        </MudText>
                    </MudCardContent>
                    <MudCardActions>
                        <MudSpacer />
                        <MudTooltip Text="Version History">
                            <MudIconButton Icon="@Icons.Material.Filled.History" 
                                           Color="Color.Default" Size="Size.Small"
                                           OnClick="@(() => ShowVersionHistory(rule.Id, rule.Name, RuleEntityType_RiskRule))" />
                        </MudTooltip>
                    </MudCardActions>
                </MudCard>
            </MudItem>
        }
    </MudGrid>

    @* ‚îÄ‚îÄ Custom Expression Rules ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ *@
    <MudText Typo="Typo.h6" Class="mb-2 mt-6">
        <MudIcon Icon="@Icons.Material.Filled.Tune" Size="Size.Small" Class="mr-1" />
        Custom Rules
        @if (_expressionRules.Count > 0)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Info" Class="ml-2">@_expressionRules.Count</MudChip>
        }
    </MudText>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
        User-defined rules that evaluate dynamically. Create rules with the "Add Custom Rule" button.
    </MudText>

    @if (_expressionRules.Count == 0)
    {
        <MudPaper Class="pa-6 mb-4" Elevation="0" Style="border: 2px dashed var(--mud-palette-lines-default); text-align: center;">
            <MudIcon Icon="@Icons.Material.Filled.AddCircleOutline" Size="Size.Large" Color="Color.Secondary" />
            <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mt-2">
                No custom rules yet. Click <strong>"Add Custom Rule"</strong> to create your first one.
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1">
                Example: Flag transfers over $50,000 to Nigeria, or flag customers with more than 3 flagged transactions.
            </MudText>
        </MudPaper>
    }
    else
    {
        <MudGrid>
            @foreach (var rule in _expressionRules)
            {
                <MudItem xs="12" md="6">
                    <MudCard Elevation="2">
                        <MudCardHeader>
                            <CardHeaderContent>
                                <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                    <MudStack>
                                        <MudText Typo="Typo.h6">@rule.Name</MudText>
                                        <MudStack Row="true" Spacing="1">
                                            <MudChip T="string" Size="Size.Small" Color="@GetCategoryColor(rule.Category)">
                                                @rule.Category
                                            </MudChip>
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Filled" Color="Color.Info">
                                                Custom
                                            </MudChip>
                                        </MudStack>
                                    </MudStack>
                                    <MudSelect T="string" Value="@rule.Mode" Label="Mode"
                                               ValueChanged="@((val) => ChangeRuleMode(rule, val))"
                                               Variant="Variant.Outlined" Style="max-width: 140px;"
                                               Margin="Margin.Dense">
                                        <MudSelectItem T="string" Value="@("Active")">‚úÖ Active</MudSelectItem>
                                        <MudSelectItem T="string" Value="@("Shadow")">üëÅ Shadow</MudSelectItem>
                                        <MudSelectItem T="string" Value="@("Disabled")">‚õî Disabled</MudSelectItem>
                                    </MudSelect>
                                </MudStack>
                            </CardHeaderContent>
                        </MudCardHeader>
                        <MudCardContent>
                            @* Show the expression condition *@
                            <MudPaper Class="pa-2 mb-3" Elevation="0" Style="background-color: var(--mud-palette-background-grey);">
                                <MudText Typo="Typo.body2">
                                    <MudIcon Icon="@Icons.Material.Filled.FilterAlt" Size="Size.Small" Class="mr-1" />
                                    When <strong>@GetFieldDisplayName(rule.ExpressionField)</strong>
                                    @GetOperatorDisplay(rule.ExpressionOperator)
                                    <strong>@rule.ExpressionValue</strong>
                                    ‚Üí add <strong>@rule.ScoreWeight pts</strong>
                                </MudText>
                            </MudPaper>

                            @if (!string.IsNullOrEmpty(rule.Description))
                            {
                                <MudText Typo="Typo.body2" Class="mb-2">@rule.Description</MudText>
                            }

                            <MudGrid>
                                <MudItem xs="6">
                                    <MudTextField T="string" Label="Condition Value"
                                                  Value="@rule.ExpressionValue" ReadOnly="true"
                                                  Variant="Variant.Outlined" Disabled="true" />
                                </MudItem>
                                <MudItem xs="6">
                                    <MudNumericField T="int" Label="Score Weight" 
                                                     Value="@rule.ScoreWeight"
                                                     ValueChanged="@((val) => UpdateWeight(rule, val))"
                                                     Variant="Variant.Outlined"
                                                     Min="0" Max="50"
                                                     Disabled="@(rule.Mode != "Active")" />
                                </MudItem>
                            </MudGrid>
                            
                            <MudText Typo="Typo.caption" Class="mt-2">
                                Last updated: @rule.UpdatedAt.ToString("MM/dd HH:mm") by <strong>@(rule.UpdatedBy ?? "system")</strong>
                            </MudText>
                        </MudCardContent>
                        <MudCardActions>
                            <MudSpacer />
                            <MudTooltip Text="Version History">
                                <MudIconButton Icon="@Icons.Material.Filled.History" 
                                               Color="Color.Default" Size="Size.Small"
                                               OnClick="@(() => ShowVersionHistory(rule.Id, rule.Name, RuleEntityType_RiskRule))" />
                            </MudTooltip>
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                           Color="Color.Error" Size="Size.Small"
                                           OnClick="@(() => DeleteRule(rule))" />
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }

    @* ‚îÄ‚îÄ Compound Rules (AND/OR groups) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ *@
    <MudText Typo="Typo.h6" Class="mb-2 mt-6">
        <MudIcon Icon="@Icons.Material.Filled.AccountTree" Size="Size.Small" Class="mr-1" />
        Compound Rules
        @if (_compoundRules.Count > 0)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Tertiary" Class="ml-2">@_compoundRules.Count</MudChip>
        }
    </MudText>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
        Multi-condition rules that combine fields with AND/OR logic. More powerful than single-condition rules.
    </MudText>

    @if (_compoundRules.Count == 0)
    {
        <MudPaper Class="pa-6 mb-4" Elevation="0" Style="border: 2px dashed var(--mud-palette-lines-default); text-align: center;">
            <MudIcon Icon="@Icons.Material.Filled.AccountTree" Size="Size.Large" Color="Color.Secondary" />
            <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mt-2">
                No compound rules yet. Click <strong>"Add Compound Rule"</strong> to create multi-condition rules.
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1">
                Example: Flag when Amount > $5,000 <strong>AND</strong> Source Country = NG <strong>AND</strong> Customer Txns &lt; 3
            </MudText>
        </MudPaper>
    }
    else
    {
        <MudGrid>
            @foreach (var group in _compoundRules)
            {
                <MudItem xs="12" md="6">
                    <MudCard Elevation="2" Style="border-left: 4px solid var(--mud-palette-tertiary);">
                        <MudCardHeader>
                            <CardHeaderContent>
                                <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                    <MudStack>
                                        <MudText Typo="Typo.h6">‚ö° @group.Name</MudText>
                                        <MudStack Row="true" Spacing="1">
                                            <MudChip T="string" Size="Size.Small" Color="@GetCategoryColor(group.Category)">
                                                @group.Category
                                            </MudChip>
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Filled"
                                                     Color="@(group.LogicalOperator == "AND" ? Color.Primary : Color.Warning)">
                                                @group.LogicalOperator ¬∑ @group.Conditions.Count conditions
                                            </MudChip>
                                        </MudStack>
                                    </MudStack>
                                    <MudSelect T="string" Value="@group.Mode" Label="Mode"
                                               ValueChanged="@((val) => ChangeCompoundRuleMode(group, val))"
                                               Variant="Variant.Outlined" Style="max-width: 140px;"
                                               Margin="Margin.Dense">
                                        <MudSelectItem T="string" Value="@("Active")">‚úÖ Active</MudSelectItem>
                                        <MudSelectItem T="string" Value="@("Shadow")">üëÅ Shadow</MudSelectItem>
                                        <MudSelectItem T="string" Value="@("Disabled")">‚õî Disabled</MudSelectItem>
                                    </MudSelect>
                                </MudStack>
                            </CardHeaderContent>
                        </MudCardHeader>
                        <MudCardContent>
                            @* Show each condition *@
                            @foreach (var condition in group.Conditions.OrderBy(c => c.OrderIndex))
                            {
                                <MudPaper Class="pa-2 mb-1" Elevation="0" Style="background-color: var(--mud-palette-background-grey);">
                                    <MudText Typo="Typo.body2">
                                        <MudIcon Icon="@Icons.Material.Filled.ChevronRight" Size="Size.Small" />
                                        <strong>@GetFieldDisplayName(condition.ExpressionField)</strong>
                                        @GetOperatorDisplay(condition.ExpressionOperator)
                                        <strong>@condition.ExpressionValue</strong>
                                    </MudText>
                                </MudPaper>
                            }

                            <MudStack Row="true" AlignItems="AlignItems.Center" Class="mt-3" Spacing="2">
                                <MudNumericField T="int" Label="Risk Points" 
                                                 Value="@group.RiskPoints"
                                                 ValueChanged="@((val) => UpdateCompoundWeight(group, val))"
                                                 Variant="Variant.Outlined"
                                                 Min="0" Max="50"
                                                 Disabled="@(group.Mode != "Active")"
                                                 Style="max-width: 140px;" />
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    Created @group.CreatedAt.ToString("MM/dd") by @group.CreatedBy
                                </MudText>
                            </MudStack>
                        </MudCardContent>
                        <MudCardActions>
                            <MudSpacer />
                            <MudTooltip Text="Version History">
                                <MudIconButton Icon="@Icons.Material.Filled.History" 
                                               Color="Color.Default" Size="Size.Small"
                                               OnClick="@(() => ShowVersionHistory(group.Id, group.Name, RuleEntityType_RuleGroup))" />
                            </MudTooltip>
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                           Color="Color.Error" Size="Size.Small"
                                           OnClick="@(() => DeleteCompoundRule(group))" />
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }

    <MudPaper Class="pa-4 mt-4" Elevation="2">
        <MudText Typo="Typo.h6" Class="mb-3">Risk Level Thresholds</MudText>
        <MudText Typo="Typo.body2" Class="mb-3">
            These thresholds determine how the cumulative risk score maps to risk levels:
        </MudText>
        <MudGrid>
            <MudItem xs="6" sm="3">
                <MudPaper Class="pa-3" Style="background-color: var(--mud-palette-success); color: white;">
                    <MudText Typo="Typo.subtitle2">Low Risk</MudText>
                    <MudText Typo="Typo.h5">0 - 25</MudText>
                    <MudText Typo="Typo.caption">Auto-approved if ‚â§ 25</MudText>
                </MudPaper>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudPaper Class="pa-3" Style="background-color: var(--mud-palette-warning); color: white;">
                    <MudText Typo="Typo.subtitle2">Medium Risk</MudText>
                    <MudText Typo="Typo.h5">26 - 50</MudText>
                    <MudText Typo="Typo.caption">Requires review</MudText>
                </MudPaper>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudPaper Class="pa-3" Style="background-color: var(--mud-palette-error); color: white;">
                    <MudText Typo="Typo.subtitle2">High Risk</MudText>
                    <MudText Typo="Typo.h5">51 - 75</MudText>
                    <MudText Typo="Typo.caption">Priority review</MudText>
                </MudPaper>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudPaper Class="pa-3" Style="background-color: var(--mud-palette-dark); color: white;">
                    <MudText Typo="Typo.subtitle2">Critical</MudText>
                    <MudText Typo="Typo.h5">76 - 100</MudText>
                    <MudText Typo="Typo.caption">Immediate escalation</MudText>
                </MudPaper>
            </MudItem>
        </MudGrid>
    </MudPaper>
}

@* ‚îÄ‚îÄ Version History Overlay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ *@
@if (_showVersionHistory)
{
    <MudOverlay Visible="true" DarkBackground="true" OnClick="@(() => _showVersionHistory = false)" />
    <MudPaper Elevation="8" Style="position: fixed; top: 0; right: 0; bottom: 0; width: 480px; z-index: 1301; overflow-y: auto; display: flex; flex-direction: column;">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="pa-4" Style="border-bottom: 1px solid var(--mud-palette-lines-default);">
            <MudStack>
                <MudText Typo="Typo.h6">
                    <MudIcon Icon="@Icons.Material.Filled.History" Class="mr-1" />
                    Version History
                </MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">@_versionHistoryTitle</MudText>
            </MudStack>
            <MudIconButton Icon="@Icons.Material.Filled.Close" Size="Size.Small"
                           OnClick="@(() => _showVersionHistory = false)" />
        </MudStack>
        <div style="flex: 1; overflow-y: auto; padding: 8px;">
            @if (_versions.Count == 0)
            {
                <MudPaper Class="pa-6 ma-3" Elevation="0" Style="border: 2px dashed var(--mud-palette-lines-default); text-align: center;">
                    <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Large" Color="Color.Secondary" />
                    <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mt-2">
                        No version history yet.
                    </MudText>
                    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1">
                        Versions are recorded automatically when you change a rule's mode, threshold, weight, or risk points.
                    </MudText>
                </MudPaper>
            }
            else
            {
                @foreach (var version in _versions)
                {
                    <MudPaper Class="pa-3 ma-2" Elevation="1" Style="border-left: 3px solid var(--mud-palette-primary);">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                            <MudStack>
                                <MudText Typo="Typo.subtitle2">
                                    v@(version.VersionNumber)
                                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Default" Class="ml-1">
                                        @version.CreatedAt.ToString("MMM dd, HH:mm")
                                    </MudChip>
                                </MudText>
                                <MudText Typo="Typo.body2" Color="Color.Secondary">@version.ChangeDescription</MudText>
                                <MudText Typo="Typo.caption">by <strong>@version.ChangedBy</strong></MudText>
                            </MudStack>
                            <MudTooltip Text="Restore this version">
                                <MudIconButton Icon="@Icons.Material.Filled.RestorePage" 
                                               Color="Color.Warning" Size="Size.Small"
                                               OnClick="@(() => RollbackToVersion(version))" />
                            </MudTooltip>
                        </MudStack>
                    </MudPaper>
                }
            }
        </div>
    </MudPaper>
}

@code {
    private const string RuleEntityType_RiskRule = "RiskRule";
    private const string RuleEntityType_RuleGroup = "RuleGroup";

    private bool _loading = true;
    private List<RiskRule> _rules = new();
    private List<RiskRule> _expressionRules = new();
    private List<RuleGroup> _compoundRules = new();

    // ‚îÄ‚îÄ Suggestion state ‚îÄ‚îÄ
    private List<PayGuardAI.Core.Services.RuleSuggestion> _suggestions = new();
    private HashSet<string> _dismissedSuggestionIds = new();
    private bool _loadingSuggestions;
    private bool _suggestionsLoaded;
    private bool _suggestionsCollapsed;

    protected override async Task OnInitializedAsync()
    {
        await LoadRules();
        _ = LoadSuggestions(); // fire-and-forget so it doesn't block rules
    }

    private async Task LoadSuggestions()
    {
        _loadingSuggestions = true;
        StateHasChanged();
        try
        {
            var tenantId = TenantContext.TenantId ?? "";
            var allSuggestions = await SuggestionService.GenerateSuggestionsAsync(tenantId);
            _suggestions = allSuggestions
                .Where(s => !_dismissedSuggestionIds.Contains(s.SuggestionId))
                .ToList();
            _suggestionsLoaded = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Could not load suggestions: {ex.Message}", Severity.Warning);
        }
        finally
        {
            _loadingSuggestions = false;
            StateHasChanged();
        }
    }

    private async Task LoadRules()
    {
        _loading = true;
        try
        {
            var allRules = await DbContext.RiskRules
                .OrderBy(r => r.Category).ThenBy(r => r.Name)
                .ToListAsync();

            // Deduplicate: if a tenant has their own version of a built-in rule,
            // hide the global (TenantId=="") version. Expression rules are always unique.
            _rules = allRules
                .GroupBy(r => r.RuleCode)
                .Select(g => g.FirstOrDefault(r => r.TenantId != "") ?? g.First())
                .OrderBy(r => r.IsExpression)  // system rules first
                .ThenBy(r => r.Category)
                .ThenBy(r => r.Name)
                .ToList();

            _expressionRules = _rules.Where(r => r.IsExpression).ToList();

            // Load compound rules
            _compoundRules = await DbContext.RuleGroups
                .Include(g => g.Conditions)
                .OrderBy(g => g.Name)
                .ToListAsync();
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task ChangeRuleMode(RiskRule rule, string mode)
    {
        await VersioningService.SnapshotRuleAsync(rule, CurrentUser.UserName, $"Mode: {rule.Mode} ‚Üí {mode}");
        rule.Mode = mode;
        rule.UpdatedAt = DateTime.UtcNow;
        rule.UpdatedBy = CurrentUser.UserName;
        await DbContext.SaveChangesAsync();

        var label = mode switch
        {
            "Active" => "activated",
            "Shadow" => "set to shadow mode (evaluates but won't score)",
            "Disabled" => "disabled",
            _ => "updated"
        };
        var severity = mode switch
        {
            "Active" => Severity.Success,
            "Shadow" => Severity.Warning,
            _ => Severity.Info
        };
        Snackbar.Add($"Rule '{rule.Name}' {label}", severity);
    }

    private async Task UpdateThreshold(RiskRule rule, decimal value)
    {
        await VersioningService.SnapshotRuleAsync(rule, CurrentUser.UserName, $"Threshold: {rule.Threshold} ‚Üí {value}");
        rule.Threshold = value;
        rule.UpdatedAt = DateTime.UtcNow;
        rule.UpdatedBy = CurrentUser.UserName;
        await DbContext.SaveChangesAsync();
        Snackbar.Add($"Threshold updated for '{rule.Name}'", Severity.Info);
    }

    private async Task UpdateWeight(RiskRule rule, int value)
    {
        await VersioningService.SnapshotRuleAsync(rule, CurrentUser.UserName, $"Weight: {rule.ScoreWeight} ‚Üí {value}");
        rule.ScoreWeight = value;
        rule.UpdatedAt = DateTime.UtcNow;
        rule.UpdatedBy = CurrentUser.UserName;
        await DbContext.SaveChangesAsync();
        Snackbar.Add($"Weight updated for '{rule.Name}'", Severity.Info);
    }

    // ‚îÄ‚îÄ Suggestion Actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private async Task CreateRuleFromSuggestion(PayGuardAI.Core.Services.RuleSuggestion suggestion)
    {
        var ruleCode = $"EXPR_{Guid.NewGuid().ToString("N")[..8].ToUpperInvariant()}";

        decimal threshold = 0;
        decimal.TryParse(suggestion.ExpressionValue, out threshold);

        var rule = new RiskRule
        {
            Id = Guid.NewGuid(),
            TenantId = TenantContext.TenantId ?? "",
            Name = suggestion.Name,
            RuleCode = ruleCode,
            Description = suggestion.Description,
            Category = suggestion.Category,
            Threshold = threshold,
            ScoreWeight = suggestion.SuggestedWeight,
            ExpressionField = suggestion.ExpressionField,
            ExpressionOperator = suggestion.ExpressionOperator,
            ExpressionValue = suggestion.ExpressionValue,
            Mode = "Shadow", // Start in shadow mode for safety
            UpdatedAt = DateTime.UtcNow,
            UpdatedBy = CurrentUser.UserName
        };

        DbContext.RiskRules.Add(rule);
        await DbContext.SaveChangesAsync();
        Snackbar.Add($"Rule '{rule.Name}' created in Shadow mode ‚Äî test it before activating!", Severity.Success);

        // Remove from suggestions list
        _suggestions.RemoveAll(s => s.SuggestionId == suggestion.SuggestionId);
        await LoadRules();
    }

    private void DismissSuggestion(PayGuardAI.Core.Services.RuleSuggestion suggestion)
    {
        _dismissedSuggestionIds.Add(suggestion.SuggestionId);
        _suggestions.RemoveAll(s => s.SuggestionId == suggestion.SuggestionId);
        Snackbar.Add("Suggestion dismissed", Severity.Info);
    }

    // ‚îÄ‚îÄ Suggestion Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private static string GetPatternIcon(PayGuardAI.Core.Services.SuggestionPattern pattern) => pattern switch
    {
        PayGuardAI.Core.Services.SuggestionPattern.AmountCluster => "üí∞",
        PayGuardAI.Core.Services.SuggestionPattern.CorridorHotspot => "üåç",
        PayGuardAI.Core.Services.SuggestionPattern.TimeAnomaly => "üïê",
        PayGuardAI.Core.Services.SuggestionPattern.RoundAmountSpike => "üî¢",
        PayGuardAI.Core.Services.SuggestionPattern.VelocityBurst => "‚ö°",
        PayGuardAI.Core.Services.SuggestionPattern.CurrencyPairRisk => "üí±",
        PayGuardAI.Core.Services.SuggestionPattern.NewCustomerRisk => "üÜï",
        PayGuardAI.Core.Services.SuggestionPattern.RepeatOffender => "üîÅ",
        _ => "üí°"
    };

    private static Color GetConfidenceColor(int confidence) => confidence switch
    {
        >= 75 => Color.Success,
        >= 50 => Color.Warning,
        _ => Color.Default
    };
    
    private async Task OpenAddRuleDialog()
    {
        var parameters = new DialogParameters<AddRuleDialog>();
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<AddRuleDialog>("Create Custom Rule", parameters, options);
        var result = await dialog.Result;
        
        if (result is { Canceled: false, Data: RiskRule newRule })
        {
            DbContext.RiskRules.Add(newRule);
            await DbContext.SaveChangesAsync();
            Snackbar.Add($"Custom rule '{newRule.Name}' created!", Severity.Success);
            await LoadRules();
        }
    }
    
    private async Task DeleteRule(RiskRule rule)
    {
        // Only allow deleting expression (custom) rules, not built-in system rules
        if (rule.IsBuiltIn)
        {
            Snackbar.Add("System rules cannot be deleted ‚Äî disable them instead.", Severity.Warning);
            return;
        }

        var confirmed = await DialogService.ShowMessageBox(
            "Delete Custom Rule",
            $"Are you sure you want to delete '{rule.Name}'? This action cannot be undone.",
            yesText: "Delete", cancelText: "Cancel");
        
        if (confirmed == true)
        {
            DbContext.RiskRules.Remove(rule);
            await DbContext.SaveChangesAsync();
            Snackbar.Add($"Rule '{rule.Name}' deleted", Severity.Warning);
            await LoadRules();
        }
    }

    // ‚îÄ‚îÄ Compound Rule Handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private async Task OpenAddCompoundRuleDialog()
    {
        var parameters = new DialogParameters<AddCompoundRuleDialog>();
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<AddCompoundRuleDialog>("Create Compound Rule", parameters, options);
        var result = await dialog.Result;
        
        if (result is { Canceled: false, Data: RuleGroup newGroup })
        {
            // Set tenant context
            newGroup.TenantId = CurrentUser.TenantId;
            foreach (var condition in newGroup.Conditions)
            {
                condition.RuleGroupId = newGroup.Id;
            }

            DbContext.RuleGroups.Add(newGroup);
            await DbContext.SaveChangesAsync();
            Snackbar.Add($"Compound rule '{newGroup.Name}' created with {newGroup.Conditions.Count} conditions!", Severity.Success);
            await LoadRules();
        }
    }

    private async Task ChangeCompoundRuleMode(RuleGroup group, string mode)
    {
        await VersioningService.SnapshotCompoundRuleAsync(group, CurrentUser.UserName, $"Mode: {group.Mode} ‚Üí {mode}");
        group.Mode = mode;
        group.UpdatedAt = DateTime.UtcNow;
        await DbContext.SaveChangesAsync();

        var label = mode switch
        {
            "Active" => "activated",
            "Shadow" => "set to shadow mode",
            "Disabled" => "disabled",
            _ => "updated"
        };
        var severity = mode switch
        {
            "Active" => Severity.Success,
            "Shadow" => Severity.Warning,
            _ => Severity.Info
        };
        Snackbar.Add($"Compound rule '{group.Name}' {label}", severity);
    }

    private async Task UpdateCompoundWeight(RuleGroup group, int value)
    {
        await VersioningService.SnapshotCompoundRuleAsync(group, CurrentUser.UserName, $"RiskPoints: {group.RiskPoints} ‚Üí {value}");
        group.RiskPoints = value;
        group.UpdatedAt = DateTime.UtcNow;
        await DbContext.SaveChangesAsync();
        Snackbar.Add($"Risk points updated for '{group.Name}'", Severity.Info);
    }

    private async Task DeleteCompoundRule(RuleGroup group)
    {
        var confirmed = await DialogService.ShowMessageBox(
            "Delete Compound Rule",
            $"Are you sure you want to delete '{group.Name}'? All {group.Conditions.Count} conditions will be removed. This action cannot be undone.",
            yesText: "Delete", cancelText: "Cancel");
        
        if (confirmed == true)
        {
            DbContext.RuleGroups.Remove(group);
            await DbContext.SaveChangesAsync();
            Snackbar.Add($"Compound rule '{group.Name}' deleted", Severity.Warning);
            await LoadRules();
        }
    }

    // ‚îÄ‚îÄ UI Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private Color GetCategoryColor(string category) => category switch
    {
        "Amount" => Color.Primary,
        "Velocity" => Color.Secondary,
        "Geography" => Color.Error,
        "Pattern" => Color.Info,
        _ => Color.Default
    };

    /// <summary>Whether the threshold field is meaningful for this built-in rule.</summary>
    private static bool IsThresholdUsed(string ruleCode) => ruleCode switch
    {
        "HIGH_AMOUNT" => true,
        "VELOCITY_24H" => true,
        "NEW_CUSTOMER" => true,
        "ROUND_AMOUNT" => true,
        _ => false  // HIGH_RISK_CORRIDOR and UNUSUAL_TIME ignore threshold
    };

    /// <summary>Contextual label for the threshold field.</summary>
    private static string GetThresholdLabel(string ruleCode) => ruleCode switch
    {
        "HIGH_AMOUNT" => "Amount ($)",
        "VELOCITY_24H" => "Max Txns/Day",
        "NEW_CUSTOMER" => "Min Txns",
        "ROUND_AMOUNT" => "Min Amount ($)",
        _ => "Threshold"
    };

    /// <summary>Hint shown when threshold is not applicable.</summary>
    private static string GetThresholdHint(string ruleCode) => ruleCode switch
    {
        "HIGH_RISK_CORRIDOR" => "Uses sanctioned country list",
        "UNUSUAL_TIME" => "Hardcoded: 2-5 AM UTC",
        _ => "Not configurable"
    };

    /// <summary>Human-readable explanation of what the current threshold means.</summary>
    private static string GetThresholdExplanation(RiskRule rule) => rule.RuleCode switch
    {
        "HIGH_AMOUNT" => $"Flags transactions ‚â• ${rule.Threshold:N0}",
        "VELOCITY_24H" => $"Flags when ‚â• {rule.Threshold:N0} transactions in 24 hours",
        "NEW_CUSTOMER" => $"Flags customers with < {rule.Threshold:N0} total transactions",
        "ROUND_AMOUNT" => $"Flags round amounts (√∑1000) when ‚â• ${rule.Threshold:N0}",
        _ => ""
    };

    private static string GetFieldDisplayName(string? field)
    {
        if (string.IsNullOrEmpty(field)) return "Unknown";
        return RiskRule.ExpressionFields.TryGetValue(field, out var info) ? info.DisplayName : field;
    }

    private static string GetOperatorDisplay(string? op) => op switch
    {
        ">=" => "is ‚â•",
        "<=" => "is ‚â§",
        ">"  => "is >",
        "<"  => "is <",
        "==" => "equals",
        "!=" => "does not equal",
        "contains" => "contains",
        "not_contains" => "does not contain",
        _ => op ?? ""
    };

    // ‚îÄ‚îÄ Version History ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private bool _showVersionHistory;
    private string _versionHistoryTitle = "";
    private string _versionEntityType = "";
    private Guid _versionEntityId;
    private List<PayGuardAI.Core.Entities.RuleVersion> _versions = new();

    private async Task ShowVersionHistory(Guid entityId, string ruleName, string entityType)
    {
        _versionEntityId = entityId;
        _versionEntityType = entityType;
        _versionHistoryTitle = ruleName;
        _versions = await VersioningService.GetVersionHistoryAsync(entityId);
        _showVersionHistory = true;
        StateHasChanged();
    }

    private async Task RollbackToVersion(PayGuardAI.Core.Entities.RuleVersion version)
    {
        var confirmed = await DialogService.ShowMessageBox(
            "Rollback Rule",
            $"Restore '{version.RuleName}' to version {version.VersionNumber} from {version.CreatedAt:MMM dd, HH:mm}?\n\nThe current config will be auto-saved as a new version before restoring.",
            yesText: "Rollback", cancelText: "Cancel");

        if (confirmed != true) return;

        if (version.EntityType == RuleEntityType_RiskRule)
        {
            var rule = await VersioningService.RollbackRuleAsync(version.Id, CurrentUser.UserName);
            if (rule != null)
            {
                Snackbar.Add($"Rule '{rule.Name}' restored to v{version.VersionNumber}", Severity.Success);
            }
            else
            {
                Snackbar.Add("Rollback failed ‚Äî rule not found or snapshot corrupted", Severity.Error);
            }
        }
        else
        {
            var group = await VersioningService.RollbackCompoundRuleAsync(version.Id, CurrentUser.UserName);
            if (group != null)
            {
                Snackbar.Add($"Compound rule '{group.Name}' restored to v{version.VersionNumber}", Severity.Success);
            }
            else
            {
                Snackbar.Add("Rollback failed ‚Äî rule not found or snapshot corrupted", Severity.Error);
            }
        }

        _showVersionHistory = false;
        await LoadRules();
    }
}
